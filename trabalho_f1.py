# -*- coding: utf-8 -*-
"""Trabalho F1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lfQLERo4ZBGA2HXcO4eLypw2QroFKZo4
"""

# ================================
# Instala√ß√£o e importa√ß√µes
# ================================
!pip install fastf1

import os
import pandas as pd
import fastf1
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
import numpy as np

# Criar cache
os.makedirs("/content/f1_cache", exist_ok=True)
fastf1.Cache.enable_cache('/content/f1_cache')

# ================================
# Fun√ß√µes auxiliares
# ================================
def to_seconds(td):
    if pd.isnull(td):
        return None
    return td.total_seconds()

def create_dataset(laps, le=None, fit_le=False):
    df = pd.DataFrame({
        'Driver': laps['Driver'],
        'LapNumber': laps['LapNumber'],
        'LapTime': laps['LapTime'].apply(to_seconds),
        'Sector1': laps['Sector1Time'].apply(to_seconds),
        'Sector2': laps['Sector2Time'].apply(to_seconds),
        'Sector3': laps['Sector3Time'].apply(to_seconds),
        'Compound': laps['Compound'].str.upper()
    }).dropna()

    if fit_le:
        df['Compound'] = df['Compound'].fillna('HARD')
        df['CompoundCode'] = le.fit_transform(df['Compound'])
        return df
    else:
        # Substitui compostos desconhecidos pelo composto mais frequente
        df['Compound'] = df['Compound'].apply(lambda x: x if x in le.classes_ else 'HARD')
        df['CompoundCode'] = le.transform(df['Compound'])
        return df

# ================================
# CONFIGURA√á√ÉO DE CORRIDAS E ANOS
# ================================
GP = 'Bahrain'
ANO_TREINO = 2023
ANO_TESTE = 2024

# ================================
# CARREGAR DADOS DE TREINO
# ================================
train_session = fastf1.get_session(ANO_TREINO, GP, 'R')
train_session.load()
laps_train = train_session.laps

# CARREGAR DADOS DE TESTE
test_session = fastf1.get_session(ANO_TESTE, GP, 'R')
test_session.load()
laps_test = test_session.laps

# ================================
# LabelEncoder universal
# ================================
todos_compostos = pd.concat([laps_train['Compound'], laps_test['Compound']]).str.upper().unique()
le = LabelEncoder()
le.fit(todos_compostos)

df_train = create_dataset(laps_train, le=le, fit_le=True)
df_train['GoodLap'] = df_train.groupby('Driver')['LapTime'].transform(lambda x: (x < x.mean()).astype(int))
feature_cols = ['LapNumber', 'Sector1', 'Sector2', 'Sector3', 'CompoundCode']
X_train = df_train[feature_cols]
y_train = df_train['GoodLap']

df_test = create_dataset(laps_test, le=le, fit_le=False)
df_test['GoodLap'] = df_test.groupby('Driver')['LapTime'].transform(lambda x: (x < x.mean()).astype(int))
X_test = df_test[feature_cols]
y_test = df_test['GoodLap']

# ================================
# TREINAR MODELO
# ================================
rf = RandomForestClassifier(n_estimators=200, random_state=42)
rf.fit(X_train, y_train)

print("üìä Acur√°cia na corrida de teste:", accuracy_score(y_test, rf.predict(X_test)))

# ================================
# SIMULA√á√ÉO DE PITSTOPS PROBABIL√çSTICA
# ================================
total_voltas = int(df_test['LapNumber'].max())
durabilidade = {"SOFT": 15, "MEDIUM": 25, "HARD": 35}  # voltas m√©dias por composto
recomendacoes = []

for driver in df_test['Driver'].unique():
    driver_laps = df_test[df_test['Driver'] == driver].sort_values('LapNumber').reset_index(drop=True)

    for idx, row in driver_laps.iterrows():
        lap = int(row['LapNumber'])
        ultima_volta = row

        melhores = []
        for comp in le.classes_:
            X_pneu = pd.DataFrame({
                'LapNumber': [lap],
                'Sector1': [ultima_volta['Sector1']],
                'Sector2': [ultima_volta['Sector2']],
                'Sector3': [ultima_volta['Sector3']],
                'CompoundCode': [le.transform([comp])[0]]
            })
            prob = rf.predict_proba(X_pneu)[0][1]
            pred_novo = np.random.rand() < prob
            melhores.append((comp, pred_novo))

        best_comp, best_pred = max(melhores, key=lambda x: x[1])
        estimativa_pits = total_voltas // durabilidade.get(best_comp, 20)

        recomendacoes.append((
            driver,
            lap,
            best_comp,
            "Boa" if best_pred else "Ruim",
            estimativa_pits
        ))

# ================================
# EXIBI√á√ÉO COMPLETA
# ================================
df_recomendacoes = pd.DataFrame(
    recomendacoes,
    columns=["Piloto", "Volta Recomendada", "Pneu Sugerido", "Expectativa", "Pitstops Estimados"]
)

pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)
pd.set_option('display.width', 1000)
pd.set_option('display.max_colwidth', None)

print("\nüîß Estrat√©gia din√¢mica de pitstops probabil√≠stica:")
print(df_recomendacoes)

# Exportar CSV
df_recomendacoes.to_csv("estrategia_pitstops.csv", index=False)